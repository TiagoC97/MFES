class Group
types
	public String1 = seq1 of char;
values
-- TODO Define values here
instance variables
	private clients: set of Client:= {};
 	private groupInbox: seq of String1 := [];
 	private offers: seq of String1 := [];
	private club: [Club];
	
operations

	-- constructor
 	public Group: Client * Club  ==> Group
 	Group(client, newClub) == 
	(
 		clients := {client};
 		club := newClub;
 		return self
 	)
 	pre client in set club.getClients()
 	post clients = {client} and groupInbox = [] and offers = [] and club = newClub;

 	-- add a new client to the group
 	public addClient: Client ==> ()
 	addClient(client) == clients := clients union {client}
 	pre client not in set clients
 	post clients = clients~ union {client};

  -- remove a client from the group
 	public removeClient: Client ==> ()
 	removeClient(client) == clients := clients \ {client}
 	pre client in set clients
 	post clients = clients~ \ {client};

 	-- add a new offer for the group
 	public sendOffer: String1 ==> ()
 	sendOffer(offer) == offers := [offer] ^ offers
 	post offers = offer ^ offers~;

 	 -- add a new message to the group inbox
 	public sendMessage: User * String1 ==> ()
 	sendMessage(user, msg) == groupInbox := [msg] ^ groupInbox
 	pre user in set clients or (club <> nil and user = club.getOwner())
 	post groupInbox = msg ^ groupInbox~;

  -- check the inbox (the client must belong to the group)
 	public pure checkInbox: Client ==> seq of String1
 	checkInbox(client) == return groupInbox
 	pre client in set clients;

 	 -- check the offers the group received (the client must belong to the group)
 	public pure checkOffers: Client ==> seq of String1
 	checkOffers(client) == return offers
 	pre client in set clients;

functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end Group
